#lang scheme

(define (entry tree) (car tree)) 
(define (left tree) (cadr tree)) 
(define (right tree) (caddr tree))
(define (priority tree) (cadddr tree))

(define (make-treap entry left right priority) 
  (list entry left right priority)
)

(define (contains-treap? x tree)
  (cond ((null? tree) false) 
        ((= x (entry tree)) true)
        ((< x (entry tree)) (contains-treap? x (left tree)))
        ((> x (entry tree)) (contains-treap? x (right tree)))
  )
)

(define (merge-treap L R)
  (cond ((null? L) R)
        ((null? R) L)
        ((> (priority L) (priority R)) 
         (let ((newR (merge-treap (right L) R)))
           (make-treap (entry L) (left L) newR (priority L) )
         )
        )
        (else 
         (let ((newL (merge-treap L (left R))))
           (make-treap (entry R) newL (right R) (priority R))
         )
        )
  )
)

(define (split-treap x T)
  (cond ((null? T) (cons null null))
        ((<= (entry T) x) 
          (let ((splitT (split-treap x (right T))))
            (cons (make-treap (entry T) (left T) (car splitT) (priority T)) (cdr splitT))
          )
        )
        (else 
         (let ((splitT (split-treap x (left T)))) 
           (cons (car splitT) (make-treap (entry T) (cdr splitT) (right T) (priority T)))   
         )
        )
  )
)

(define (insert-treap x tree)
  (define (insert-treap-internal x T) 
    (let ((splitT (split-treap x T))) 
      (merge-treap (merge-treap (car splitT) (make-treap x null null (random))) (cdr splitT))
    ) 
  )
  (cond ((null? tree) (make-treap x null null (random)))
        ((contains-treap? x tree) tree)
        (else (insert-treap-internal x tree))
  )
)

(define (delete-treap x tree) 
  (cond
    ((contains-treap? x tree)
      (let* ((splitT (split-treap (- x 1) tree)) (splitR (split-treap x (cdr splitT)))) 
        (merge-treap (car splitT) (cdr splitR))
      ) 
    )
    (else tree)
  )
)
